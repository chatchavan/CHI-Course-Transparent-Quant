---
title: "Session 3 Uncertainty visualizations"
author: "Xiaoying Pu, Lace Padilla"
date: "3/3/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidymodels)
library(modelr)
library(brms)
library(tidybayes)
library(ggdist)
library(distributional)
library(ordinal)
library(ggrepel)
library(glue)
library(dabestr)
library(rethinking)

theme_set(theme_tidybayes())
```


## Dataset 1 Blinded with Science

```{r}
(df1 <- read_csv("data/blinded.csv") %>%
  filter(experiment == 1) %>%
  mutate(
    condition = factor(condition), 
    participant_id = paste0("P", str_pad(row_number(), 2, pad = "0")))
)
```

We modeled how `condition` (graph or no graph) affected `effectiveness`, a Likert scale rating from 1 to 9.

```{r}
df1 %>%
  arrange(effectiveness) %>%
  count(effectiveness, condition) %>%
  pivot_wider(names_from = condition, values_from = n, values_fill = 0)
```



## Dataset 1, frequentist land 


### Wilcoxon 

- point and conf interval for 

TODO: what vis can we create for the wilcoxon test (non-parametric so can't plot pretty t distributions)

```{r}
df1 %>%
  count(condition, effectiveness, name = "n") %>%
  ggplot(aes(x = effectiveness, y = n, color = condition)) + 
  geom_point()
```

```{r}
m_wilcox <-  wilcox.test(
    effectiveness ~ condition, 
    data = df1, paired = FALSE, conf.int = TRUE)

tidy(m_wilcox)
```


```{r}
tidy(m_wilcox) %>%
  ggplot(aes(x = estimate, y = 0)) + 
  geom_pointinterval(aes(xmin = conf.low, xmax = conf.high)) 
```


### t-test

Baseline: table/textual reporting

```{r dat1-frequentist-model2}
m_t_test <- t.test(
  effectiveness ~ condition, 
  data = df1, paired = FALSE, conf.int = TRUE)
```


```{r dat1-frequentist-model2}
m_t_test
```

t-test is equivalent to a linear model with a slope and intercept $y_i = \beta_0 + \beta_1 x_i$ (`1 + condition` below) so using `lm` because the output is easier to wrangle (good explainer: https://lindeloev.github.io/tests-as-linear/#61_one-way_anova_and_kruskal-wallis)

```{r}
m_t_test <- lm(effectiveness ~ 1 + condition, data = df1)
```


```{r dat1-frequentist-model2}
m_t_test %>%
  tidy()

tidy(m_t_test) %>%
  ggplot(aes(x = estimate, y = term)) + 
  geom_point()

tidy(m_t_test) %>%
  ggplot(aes(xdist = dist_student_t(
    df = df.residual(m_t_test), 
    mu = estimate, sigma = std.error), y = term)) + 
  stat_pointinterval()
```

EXERCISE: does it make sense? what encoding do you prefer?

```{r dat1-frequentist-model2}
aug_df1 <- df1 %>%
  data_grid(condition) %>%
  augment(m_t_test, newdata = ., se_fit = TRUE) 


aug_df1 %>%
  ggplot(aes(y = condition)) +
  geom_jitter(aes(x = effectiveness, y = condition), data =df1, height = 0.05, alpha = .5) + 
  stat_halfeye( # EXERCIESE: change to stat_dots
    aes(xdist =dist_student_t(
      df = df.residual(m_t_test), 
      mu = .fitted, sigma = .se.fit)),
    scale = 0.7, 
    position = position_nudge(y = 0.1)) + 
  NULL
```
EXERCISE: Direct label of conditions and geoms

```{r}
(coefficients <- m_t_test %>%
  tidy() %>%
  mutate(term = c("intercept", "slope")) %>%
  select(term, estimate) %>% 
  deframe()
)
```


```{r}
df1 %>% 
  ggplot(aes(x = ifelse(condition == "graph", 0, 1), y = effectiveness)) + 
  # geom_vline(xintercept = 0, color = "#8c96c6") + 
  stat_lineribbon(aes(
    x = ifelse(condition == "graph", 0, 1), y = NULL, 
    ydist = dist_student_t(
      df = df.residual(m_t_test), 
      mu = .fitted, sigma = .se.fit)), 
    data = aug_df1, alpha = 0.3, fill = "#8c96c6") +
  # geom_abline(
  #   intercept = coefficients["intercept"], 
  #   slope =  coefficients["slope"],
  #   color = "#8c96c6") + 
  geom_count(aes(
    # alpha = rescale(..prop.., to = c(0.3, 1))
    ), color = "gray25",) + 
  # geom_point() +
  geom_label_repel(data = tibble(x =1, y = 1 * 0.18 + 6.57),
                   mapping = aes(x = x, y = y),
                   label = glue("y = {format(round(coefficients[\"intercept\"], 2), nsmall=2)} + {format(round(coefficients[\"slope\"], 2), nsmall=2)}x"), color = "#8c96c6", 
                   box.padding = 2) + 
  # geom_point(data = tibble(x = 0, y = coefficients["intercept"]),
  #                  mapping = aes(x, y),
  #                   color = "#8c96c6") + 
  labs(
    title = "What t-test/lm is about",
    subtitle = "dont encode count as size of points but that's kind of the point") + 
  xlab("condition") +
  scale_x_continuous(breaks = c(0,1), labels = c("graph (x = 0)", "no graph (x = 1)"), limits = c(-0.5, 2.7)) 
```
### Ordinal linear regression

https://bookdown.org/ajkurz/Statistical_Rethinking_recoded/monsters-and-mixtures.html#ordered-categorical-outcomes

```{r}
df1 %>%
  count(condition, effectiveness, name = "n") %>%
  ggplot(aes(x = effectiveness, y = n, color = condition)) + 
  geom_point() + 
  geom_line() + 
  NULL
```

```{r}
(cumu_df1 <- df1 %>%
  count(condition, effectiveness, name = "n") %>%
  add_row(condition = "graph", effectiveness = 2, n = 0) %>%
  complete(condition, effectiveness, fill = list(n = 0)) %>%
  group_by(condition) %>%
  mutate(
    pr_k = n / sum(n),
    cum_pr_k = cumsum(pr_k),
    cum_pr_k_1 = cum_pr_k - (pr_k),
    logit_cum_pr_k = rethinking::logit(cum_pr_k))
)
```
```{r}
cumu_df1 %>%
  filter(!is.infinite(logit_cum_pr_k)) %>%
  ggplot(aes(x = effectiveness, y = logit_cum_pr_k, color = condition, label = round(logit_cum_pr_k, 2))) + 
  geom_vline(xintercept = 6) + 
  geom_label_repel(data = cumu_df1 %>% filter(effectiveness == 6)) + 
  geom_point() + 
  geom_line() + 
  scale_x_continuous(breaks = 1:9) + 
  ylab("log-cumulative-odds")
```


```{r}
cumu_df1 %>%
  ggplot(aes(x = effectiveness, y = cum_pr_k)) + 
  geom_point() +
  geom_line() +
  geom_segment(aes(
    x = effectiveness, 
    xend = effectiveness,
    y = cum_pr_k, 
    yend = cum_pr_k_1),
    linetype = "dotted") +
  geom_segment(aes(
    x = effectiveness - 1, 
    xend = effectiveness,
    y = cum_pr_k_1, 
    yend = cum_pr_k_1),
    linetype = "dotted") +
  scale_x_continuous(breaks = 1:9) + 
  facet_grid(~condition)
```




```{r dat1-frequentist-model3}
m_olr_freq <- df1 %>% 
  mutate(effectiveness = ordered(effectiveness, levels = as.character(1:9))) %>% 
  ordinal::clm(effectiveness ~ condition, data = .)
```


```{r}
glance(m_olr_freq)

tidy(m_olr_freq)
```

```{r}
(condition_no_graph <- tidy(m_olr_freq) %>% slice_tail())

tidy(m_olr_freq) %>%
  dplyr::slice(-n()) %>%
  crossing(condition = c("graph", "no_graph")) %>%
  mutate(estimate = 
           ifelse(condition == "no_graph", 
                  estimate + condition_no_graph$estimate, 
                  estimate)) %>%
  mutate(.upper = estimate + 1.96 * std.error, 
         .lower = estimate - 1.96 * std.error)  %>%
  mutate(condition = ifelse(condition == "graph", 0, 1)) %>%
  ggplot(aes(x = condition, y = estimate, group = term)) + 
  geom_lineribbon(aes(ymin = .lower, ymax = .upper, color = term), alpha = 0.4) + 
  scale_color_viridis_d()
```



`?predict.clm`

Alternative: 
https://mjskay.github.io/tidybayes/articles/tidy-brms.html


```{r}
# TODO: how to show uncertainty with this?
# TODO: `newdata =` error
# TODO: why won't augment with `se_fit` work?

as.data.frame(predict(m_olr_freq, type.predict = "prob", se.fit = TRUE)) %>%
  bind_cols(df1 %>% select(effectiveness, condition))  %>%
  group_by(effectiveness, condition) %>% 
  slice_head() %>%
  ungroup()   %>%
  ggplot(aes(x = effectiveness, y = fit, fill = condition)) + 
  geom_col(position = "dodge") + 
  geom_pointinterval(
    aes(ymin = fit - 1.96 * se.fit, ymax = fit + 1.96 * se.fit),
    position = "dodge") + 
  scale_x_continuous(breaks = 1:9) + 
  ylab("Proportion")
  

```


## Dataset 1, Bayesian land


### Dataset 1, Bayesian t-test



```{r dat1-bayesian-model2}
dummy
df1 %>%
  data_grid(condition, effectiveness) %>%
  add_epred_draws(dummy, newdata = . ,dpar = TRUE)

```

### Dataset 1, Bayesian OLR

There're starter values and stuff, not bothered just yet https://bookdown.org/ajkurz/Statistical_Rethinking_recoded/monsters-and-mixtures.html#ordered-categorical-outcomes

```{r dat1-bayesian-model3}
# m_olr_bayes <- brm(
#   bf(effectiveness ~ condition), 
#   prior = c(
#     prior(normal(0, 10), class = Intercept),
#   ),
#   family = cumulative(),
#   data = df1,
#   seed = 99, chains = 4, cores = 4,
#   file = "data/m_olr_bayes.rds"
# )

```




## Dataset 2 Power Pose

Load the dataframe. Data dictionary/column description at https://github.com/yvonnejansen/posture/blob/master/data/exp2_column-description.csv 

```{r}
df2 <- read_csv("../02-bayesian_stats/data/exp2.csv")
```

We only modeled two variables: `change` and `condition`. 

- Each of the 80 participants were assigned to either "constrictive" or "expansive" conditions. 
- `change` is "a normalized measure for how people’s behavior changed over the course of the experiment (∼10 min)". The experiment was done in three phases where participants pumped balloons. `change` $ = \frac{\text{mean adjusted # of pumps in Phase 3 - mean adjusted # of pumps in Phase 1}}{\text{mean adjusted # of pumps in Phase 3}}$


```{r}
df2 %>%
  group_by(condition) %>%
  count()
```

```{r}
df2 %>%
  ggplot(aes(x = change, color = condition)) +  
  # geom_dots( alpha = 0.4) + 
  geom_density(outline.type = "full") + 
  xlab("Percent change") + 
  NULL
```


## Dataset 2 results

```{r}
if (!file.exists("data/dataset2.brm.student.rds")){
fit.brm <- brm(
   bf(
    change ~ condition, sigma ~ condition, 
    family = student()
  ),
  prior = c(
    prior(normal(0, 2), class = "b"),
    prior(cauchy(0, 2), class = "b", dpar = "sigma"),
    prior(exponential(0.03), class = "nu"),
    prior(student_t(3, 0, 5), class = "Intercept"),
    prior(student_t(3, 0, 2), class = "Intercept", dpar = "sigma")
  ), 
  data = df2,
  seed = 99, chains = 4, cores = 4,
  file = "data/dataset2.brm.student.rds")
} else {
  fit.brm <- readRDS("data/dataset2.brm.student.rds")
}

fit.brm
get_variables(fit.brm)
```

```{r}
(grid <- df2 %>% data_grid(condition))

(means <- grid %>% 
  add_epred_draws(fit.brm) 
  )

(preds <- grid %>% 
  add_predicted_draws(fit.brm)
)
```


```{r}
df2_range <- c(min(df2$change - 20), max(df2$change + 20))
```


```{r}
means %>%
  ggplot(aes(x = .epred, y = condition)) +
  stat_pointinterval(.width = 0)+ 
  xlim(df2_range)

means %>%
  ggplot(aes(x = .epred, y = condition)) +
  stat_pointinterval() + 
  xlim(df2_range)
```


```{r}
ggplot() + 
  stat_interval(
    aes(x = .prediction, y = condition),
    data = preds) + 
  stat_dots(
    aes(x = change, y = condition), 
    data = df2, alpha = 0.5, position = position_nudge(y = 0.1) , scale = 0.8) + 
  stat_pointinterval(
    aes(x = .epred, y = condition), 
    data = means, position = position_nudge(y = -0.1)) +
  scale_color_brewer()

```

(Rethinking: think about what these all mean)

- How wide are the intervals?


```{r}
ggplot(mapping = aes(fill = condition)) + 
  stat_slab(
    aes(x = .prediction, y = condition, thickness = stat(pdf * n)),
    data = preds, scale = 0.5) + 
  stat_dots(
    aes(x = change, y = condition, side = "bottom"), 
    data = df2, alpha = 0.5, scale = 0.7) + 
  stat_pointinterval(
    aes(x = .epred, y = condition), 
    data = means) + 
  labs(title = "Rainplot") +
  xlim(df2_range)
```



```{r}
ggplot() + 
  stat_slab(aes(xdist = dist_cauchy(0, 2)))

ggplot() + 
  stat_slab(aes(xdist = dist_exponential(1/30)))
```

```{r}
grid %>% 
  add_epred_draws(fit.brm, dpar = c("mu", "sigma", "nu")) %>%
  sample_draws(30) %>%
  ggplot(aes(y = condition)) + 
  stat_slab(aes(xdist = dist_student_t(nu, mu, sigma)),
                 slab_color="gray65", alpha = 0.1, fill = NA) +
  geom_point(aes(x = change), data = df2, shape = 21, fill = "#9ECAE1",  size = 2) +
  xlim(df2_range) + 
  NULL
```

```{r}

```

