---
title: "Session 3 Uncertainty visualizations"
author: "Xiaoying Pu, Lace Padilla"
date: "3/3/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidymodels)
library(modelr)
library(tidybayes)
library(ggdist)
library(distributional)
library(ordinal)
library(ggrepel)
library(glue)

theme_set(theme_tidybayes())
```


## Dataset 1 Blinded with Science

```{r}
(df1 <- read_csv("data/blinded.csv") %>%
  filter(experiment == 1) %>%
  mutate(
    condition = factor(condition), 
    participant_id = paste0("P", str_pad(row_number(), 2, pad = "0")))
)
```

We modeled how `condition` (graph or no graph) affected `effectiveness`, a Likert scale rating from 1 to 9.

```{r}
df1 %>%
  arrange(effectiveness) %>%
  count(effectiveness, condition) %>%
  pivot_wider(names_from = condition, values_from = n, values_fill = 0)
```



## Dataset 1, frequentist land 


### Wilcoxon 

TODO: what vis can we create for the wilcoxon test (non-parametric so can't plot pretty t distributions)

```{r}
df1 %>%
  count(condition, effectiveness, name = "n") %>%
  ggplot(aes(x = effectiveness, y = n, color = condition)) + 
  geom_point()
```

```{r}
df1 %>%
  mutate(rank = rank(effectiveness)) %>%
  ggplot(aes(x = rank)) + 
  geom_histogram() + 
  facet_grid(~ condition) + 
  scale_x_continuous()
```

### t-test

Baseline: table/textual reporting

```{r dat1-frequentist-model2}
m_t_test <- t.test(
  effectiveness ~ condition, 
  data = df1, paired = FALSE, conf.int = TRUE)
```


```{r dat1-frequentist-model2}
m_t_test
```

t-test is equivalent to a linear model with a slope and intercept $y_i = \beta_0 + \beta_1 x_i$ (`1 + condition` below) so using `lm` because the output is easier to wrangle (good explainer: https://lindeloev.github.io/tests-as-linear/#61_one-way_anova_and_kruskal-wallis)

```{r}
m_t_test <- lm(effectiveness ~ 1 + condition, data = df1)
```


```{r dat1-frequentist-model2}
m_t_test %>%
  tidy()

tidy(m_t_test) %>%
  ggplot(aes(x = estimate, y = term)) + 
  geom_point()

tidy(m_t_test) %>%
  ggplot(aes(xdist = dist_student_t(
    df = df.residual(m_t_test), 
    mu = estimate, sigma = std.error), y = term)) + 
  stat_pointinterval()
```

EXERCISE: does it make sense? what encoding do you prefer?

```{r dat1-frequentist-model2}
df1 %>%
  data_grid(condition) %>%
  augment(m_t_test, newdata = ., se_fit = TRUE) %>%
  ggplot(aes(y = condition)) +
  geom_jitter(aes(x = effectiveness, y = condition), data =df1, height = 0.05, alpha = .5) + 
  stat_halfeye( # EXERCIESE: change to stat_dots
    aes(xdist =dist_student_t(
      df = df.residual(m_t_test), 
      mu = .fitted, sigma = .se.fit)),
    scale = 0.7, 
    position = position_nudge(y = 0.1)) + 
  NULL
```
EXERCISE: Direct label of conditions and geoms

```{r}
(coefficients <- m_t_test %>%
  tidy() %>%
  mutate(term = c("intercept", "slope")) %>%
  select(term, estimate) %>% 
  deframe()
)
```


```{r}
df1 %>% 
  ggplot(aes(x = ifelse(condition == "graph", 0, 1), y = effectiveness)) + 
  geom_vline(xintercept = 0, color = "#8c96c6") + 
  geom_abline(
    intercept = coefficients["intercept"], 
    slope =  coefficients["slope"],
    color = "#8c96c6") + 
  geom_count(aes(alpha = rescale(..prop.., to = c(0.3, 1))), color = "gray85",) + 
  geom_point() + 
  geom_label_repel(data = tibble(x =1.9, y = 8),
                   mapping = aes(x = x, y = y),
                   label = glue("slope: b = {format(round(coefficients[\"slope\"], 2), nsmall=2)}\nintercept: a = {format(round(coefficients[\"intercept\"], 2), nsmall=2)}"), color = "#8c96c6", 
                   box.padding = 0.5) + 
  geom_point(data = tibble(x = 0, y = coefficients["intercept"]),
                   mapping = aes(x, y),
                    color = "#8c96c6") + 
  labs(
    title = "What this data really looks like",
    subtitle = "dont encode count as size of points but that's kind of the point") + 
  xlab("condition") +
  scale_x_continuous(breaks = c(0,1), labels = c("graph (x = 0)", "no graph (x = 1)"), limits = c(-0.5, 2)) 
```


```{r dat1-frequentist-model3}
m_olr <- 
  dataset %>% 
  mutate(effectiveness = ordered(effectiveness, levels = as.character(1:9))) %>% 
  ordinal::clm(effectiveness ~ condition,
      data = .)
```


## Dataset 1, Bayesian land

```{r dat1-bayesian-model2}

```


```{r dat1-bayesian-model3}

```



## Dataset 2 Power Pose

Load the dataframe. Data dictionary/column description at https://github.com/yvonnejansen/posture/blob/master/data/exp2_column-description.csv 

```{r}
df2 <- read_csv("../02-bayesian_stats/data/exp2.csv")
```

We only modeled two variables: `change` and `condition`. 

- Each of the 80 participants were assigned to either "constrictive" or "expansive" conditions. 
- `change` is "a normalized measure for how people’s behavior changed over the course of the experiment (∼10 min)". The experiment was done in three phases where participants pumped balloons. `change` $ = \frac{\text{mean adjusted # of pumps in Phase 3 - mean adjusted # of pumps in Phase 1}}{\text{mean adjusted # of pumps in Phase 3}}$


```{r}
df2 %>%
  group_by(condition) %>%
  count()
```

```{r}
df2 %>%
  ggplot(aes(x = change, color = condition)) +  
  # geom_dots( alpha = 0.4) + 
  geom_density(outline.type = "full") + 
  xlab("Percent change") + 
  NULL
```


## Dataset 2 results

```{r}

# TODO: change to load rds
fit.brm <- readRDS("data/dataset2.brm.student.rds")
fit.brm
get_variables(fit.brm)
```

```{r}
(grid <- df2 %>% data_grid(condition))


(means <- grid %>% 
  add_epred_draws(fit.brm) 
  )

(preds <- grid %>% 
  add_predicted_draws(fit.brm)
)
```


```{r}
df2_range <- c(min(df2$change - 10), max(df2$change + 10))
```


```{r}
means %>%
  ggplot(aes(x = .epred, y = condition)) +
  stat_pointinterval(.width = 0)+ 
  xlim(df2_range)

means %>%
  ggplot(aes(x = .epred, y = condition)) +
  stat_pointinterval() + 
  xlim(df2_range)
```


```{r}
ggplot() + 
  stat_interval(
    aes(x = .prediction, y = condition),
    data = preds) + 
  stat_dots(
    aes(x = change, y = condition), 
    data = df2, alpha = 0.5, position = position_nudge(y = 0.1) , scale = 0.8) + 
  stat_pointinterval(
    aes(x = .epred, y = condition), 
    data = means, position = position_nudge(y = -0.1)) +
  scale_color_brewer()

```

(Rethinking: think about what these all mean)

- How wide are the intervals?


```{r}
ggplot(mapping = aes(fill = condition)) + 
  stat_slab(
    aes(x = .prediction, y = condition, thickness = stat(pdf * n)),
    data = preds, scale = 0.5) + 
  stat_dots(
    aes(x = change, y = condition, side = "bottom"), 
    data = df2, alpha = 0.5, scale = 0.7) + 
  stat_pointinterval(
    aes(x = .epred, y = condition), 
    data = means) + 
  labs(title = "Rainplot") + 
  xlim(df2_range)
```



```{r}
ggplot() + 
  stat_slab(aes(xdist = dist_cauchy(0, 2)))

ggplot() + 
  stat_slab(aes(xdist = dist_exponential(30)))
```

```{r}
grid %>% 
  add_epred_draws(fit.brm, dpar = c("mu", "sigma", "nu")) %>%
  sample_draws(30) %>%
  ggplot(aes(y = condition)) + 
  stat_slab(aes(xdist = dist_student_t(nu, mu, sigma)),
                 slab_color="gray65", alpha = 0.1, fill = NA) +
  geom_point(aes(x = change), data = df2, shape = 21, fill = "#9ECAE1",  size = 2) + 
  xlim(df2_range)
```

```{r}

```

